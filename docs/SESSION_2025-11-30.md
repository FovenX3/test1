# Session Summary - 2025-11-30

## Mission: Add DVI/HDMI Output to MVS Capture

**Initial Status**: Working USB streaming capture at 4-bit RGB
**Final Status**: DVI output working at 30fps with stable image, positioned correctly

---

## Major Achievements

### 1. DVI Output via PicoDVI Library
- Integrated PicoDVI library for HDMI output on RP2350
- Custom pin configuration for NeoPico-HD hardware:
  - DVI Data: GPIO 16-21 (3 differential pairs)
  - DVI Clock: GPIO 26-27
  - MVS signals moved: CSYNC to GPIO 22, PCLK to GPIO 28

### 2. N64-Style Architecture (from PicoDVI-N64 reference)
- **Single framebuffer** - accepts tearing, simpler design
- **Scanline callback** - DVI runs independently on Core 1
- **Blocking capture loop** - Core 0 captures, completely decoupled from DVI timing
- Much more stable than double-buffered approaches we tried

### 3. Full 15-bit RGB Capture Working
- All 5 bits per channel (R5G5B5) + dummy GND bit = 16 bits per pixel
- Proper color conversion: MVS RGB555 → RGB565 for DVI

### 4. Reference Implementations Studied
- **cps2_digiav** (marqs85) - FPGA-based MVS HDMI, provided timing constants
- **PicoDVI-N64** (kbeckmann) - Pico-based N64 capture, provided architecture pattern

---

## Key Technical Findings

### MVS Timing Constants (from cps2_digiav neogeo_frontend.v)
```c
#define NEO_H_TOTAL 384        // Total pixels per line
#define NEO_H_SYNCLEN 29       // HSYNC pulse width
#define NEO_H_BACKPORCH 28     // Back porch
#define NEO_H_ACTIVE 320       // Active pixels
#define NEO_H_ACTIVE_START 27  // Tuned for correct horizontal position

#define NEO_V_TOTAL 264        // Total lines per frame
#define NEO_V_SYNCLEN 3        // VSYNC pulse width
#define NEO_V_BACKPORCH 21     // Back porch
#define NEO_V_ACTIVE 224       // Active lines
```

### Frame Rate Mismatch
- **MVS**: 59.185606 Hz
- **DVI**: 60 Hz (standard 640x480p)
- **Difference**: ~0.814 frames/second
- **Result**: Occasional tearing (acceptable per user)
- **Attempted fix**: Custom 59.19Hz DVI timing - RT4K rejected it

### Memory Constraints (RP2350 has 520KB SRAM)
```
Single buffer approach (stable, 30fps):
- raw_buffer[48000 words] = 192KB
- g_framebuf[320×240] = 150KB
- Total: ~350KB (fits comfortably)

Double buffer attempt (60fps, crashed):
- raw_buffer[2][46000 words] = 368KB
- g_framebuf[320×240] = 150KB
- Total: ~520KB (too tight, heap overflow)
```

### Horizontal Alignment Fix
The image was shifting right occasionally. Fixed by:
1. **Draining sync FIFO** after vsync detection
2. **Clearing IRQ 4** before setting it for clean trigger
```c
drain_sync_fifo(pio_mvs, sm_sync);
pio_interrupt_clear(pio_mvs, 4);
pio_sm_exec(pio_mvs, sm_sync, pio_encode_irq_set(false, 4));
```

### Processing Bottleneck
- **Problem**: Frame processing takes ~16ms (one full frame time)
- **Result**: 30fps instead of 60fps
- **Attempted solution**: Double-buffer raw data, process previous while capturing next
- **Outcome**: RAM constraints prevented stable 60fps implementation

---

## Architecture Overview

### Final Working Architecture
```
Core 0: MVS Capture Loop          Core 1: DVI Output
┌─────────────────────────┐      ┌─────────────────────────┐
│ 1. Wait for vsync       │      │ scanline_callback()     │
│ 2. Drain sync FIFO      │      │ - Returns row pointers  │
│ 3. Start pixel capture  │      │ - Runs at 60Hz          │
│ 4. DMA transfer (~16ms) │      │ - Reads from g_framebuf │
│ 5. Process frame (~16ms)│      │                         │
│ 6. Loop (30fps total)   │      │ dvi_scanbuf_main_16bpp()│
└─────────────────────────┘      └─────────────────────────┘
         │                                   │
         └──────── g_framebuf ───────────────┘
                (single shared buffer)
```

### PIO Assignment
- **PIO0**: DVI output (3 state machines for TMDS encoding)
- **PIO1**: MVS sync detection + pixel capture (2 state machines)

---

## What Didn't Work

### 1. Custom 59.19Hz DVI Timing
- Created timing to match MVS exactly
- RT4K scaler rejected it (no signal)
- Standard displays may not accept non-standard refresh rates

### 2. 60fps with Double Raw Buffers
- Attempted parallel capture + processing
- RAM overflow (520KB limit too tight)
- Would need smaller buffers or optimized processing

### 3. GPIO-based HSYNC Wait
- Added explicit GPIO waits for CSYNC synchronization
- Made horizontal shifting worse, not better
- PIO-based sync is more deterministic

---

## Files Modified/Created

### Source Code
- **src/main_dvi.c** - Main DVI capture application (new)
- **src/dvi_test.c** - DVI color bar test (existing)
- **src/CMakeLists.txt** - Build configuration updates

### Documentation
- **docs/SESSION_2025-11-30.md** - This file

### Reference (cloned for future use)
- **reference/cps2_digiav/** - FPGA MVS/CPS implementation
- **reference/PicoDVI-N64/** - N64 capture reference

---

## Commits

```
2c5b025 - Simplify DVI capture using N64-style architecture
```

---

## Current Limitations

1. **30fps capture** - Processing bottleneck, need optimization for 60fps
2. **Occasional horizontal shift** - Reduced but not eliminated
3. **Tearing** - Accepted tradeoff for simpler architecture
4. **No USB streaming** - DVI-only for now (USB could be added back)

---

## Next Steps

### Optimization for 60fps
1. **Optimize process_frame()** - Use SIMD, avoid division/modulo
2. **Reduce raw buffer size** - Capture only active region
3. **Line-by-line processing** - Process during DMA (like original approach)

### Features
1. **Add USB streaming option** - Dual output capability
2. **OSD overlay** - Frame counter, status display
3. **Input latency measurement** - Compare to original signal

---

## Performance Summary

| Metric | Value |
| --- | --- |
| **Capture resolution** | 320×224 pixels |
| **Color depth** | 15-bit RGB (32,768 colors) |
| **Output resolution** | 640×480 (pixel doubled) |
| **Frame rate** | 30fps capture, 60fps display |
| **Latency** | ~1-2 frames |
| **RAM usage** | ~350KB / 520KB |
| **Stability** | Solid, no crashes |

---

## Conclusion

DVI output is working! The N64-style architecture (single framebuffer + scanline callback) proved much more stable than double-buffered approaches. While 60fps would be ideal, 30fps is acceptable for initial release. The key insight from reference implementations was to decouple capture timing from display timing completely.

**Status**: Ready for real-world testing!
